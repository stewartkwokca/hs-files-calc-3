# Runge-Kutta Solver
# Stewart Kwok

"""
Notes:
solve(tableau, t_0, x_0, t_f, delta_t, derivExpression) is the actual function that implements the Runge-Kutta Method.
The variable rk4tableau should be the first argument, if you wish to use the RK4 Butcher Tableau.
The comments below will give further instructions about input formatting for Butcher Tableaus.
"""

"""
Inputs
aWeights: an n x n 2D array (where n is the number of "final weights" (b's) in the Butcher Tableau
        representing the "intermediate weights" (a's) to calculate each slope. aWeights[i][j] must be 0 if
        j >= i; otherwise, the array cannot make a valid Butcher Tableau.

bWeights: an array of length n (same n as above), representing bottom row of Butcher Tableau (slope weights used
        to calculate final estimated value for each delta t)

Returns: 2D Array of size n x (n+1) combining aWeights and bWeights into a singular array representing Butcher Tableau
"""

def createTableau(aWeights, bWeights):
    if len(aWeights) != len(bWeights) or len(aWeights[0]) != len(bWeights):
        return "Invalid"
    for i in range(len(aWeights)):
        for j in range(i, len(aWeights)):
            if aWeights[i][j] != 0:
                return "Invalid"
    tableau = [row for row in aWeights]
    tableau.append(bWeights)
    return tableau

# Example / Test Tableaus
rk4tableau = createTableau([[0,0,0,0], [0.5,0,0,0], [0,0.5,0,0], [0, 0, 1, 0]], [1/6, 1/3, 1/3, 1/6])
threeEighthsTableau = createTableau([[0, 0, 0, 0], [1/3, 0, 0, 0], [-1/3, 1, 0, 0], [1, -1, 1, 0]], [1/8, 3/8, 3/8, 1/8])

# Estimates x at t_f, given t_0 and x_0, using tableau. This is just a helper function for solve(tableau, t_0, x_0, t_f, delta_t, derivExpression).
# In the solve function, the inputs for t_0 and x_0 are the most recently calculated t and x values.

def singleEstimate(tableau, t_0, x_0, t_f, derivExpression):
    cList = []
    for row in rk4tableau:
        c = 0;
        for num in row:
            c += num
        cList.append(c)
        
    slopes = []
    for rowNum in range(len(tableau)-1):
        xMidApprox = x_0
        for weightNum in range(len(slopes)):
            xMidApprox += tableau[rowNum][weightNum] * (t_f - t_0) * slopes[weightNum]
        t = t_0 + (cList[rowNum] * (t_f - t_0))
        x = xMidApprox
        slopes.append(eval(derivExpression))

    bList = tableau[-1]

    finalX = x_0
    for bIndex in range(len(bList)):
        finalX += bList[bIndex] * (t_f-t_0) * slopes[bIndex]

    return finalX

"""
Inputs:
tableau: 2D array of size n x (n+1), in the format generated by createTableau(aWeights, bWeights)
t_0: initial t value
x_0: initial x value
t_f: final t value
delta_t: size of "step" taken for each intermediate estimate (one iteration through Butcher Tableau)
derivExpression: string representing expression for derivative, e.g. 5*t-3*x

Output:
On row m, the output is t_m followed by x_m. That is, t_m is t_0 + ((m-1)*delta_t), and x_m is the
approximated x value at t_m.

Returns: a 2D array with 2 rows. The first row is the list of times, and the second row is the corresponding
approximated x value for each time. For example, totalOutput[0][0] should return t_0, and totalOutput[1][0]
should return x_0.
"""
def solve(tableau, t_0, x_0, t_f, delta_t, derivExpression):
    tList = [t_0]
    xList = [x_0]
    totalOutput = [tList, xList]
    print(str(tList[0]) + " " + str(xList[0]))
    while (tList[-1] < t_f):
        tList.append(tList[-1] + delta_t)
        xList.append(singleEstimate(tableau, tList[-2], xList[-1], tList[-1], derivExpression))
        print(str(tList[-1]) + " " + str(xList[-1]))  
    return totalOutput

#solve(rk4tableau, 10, 10, 20, 1, "6*t-3*x")

